@inject MenuDataService MenuDataService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject StateService stateService
@implements IDisposable
@inject IActionService ActionService
@using Aviv.Base.UI.Components.Shared
@using Microsoft.JSInterop
@using System.Text.Json
@using System.Collections.Generic
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using WMBlazorOverlayScrollbars.WMBOS

<div id="responsive-overlay" @onclick="responsivecloseFn"></div>
<aside class="app-sidebar sticky @sidebarClass" id="sidebar" @onmouseenter="() => HoverToggleInnerMenuFn(true)" @onmouseleave="() => HoverToggleInnerMenuFn(false)" @onclick="icontextOpenFn">

	<!-- Start::main-sidebar-header -->
	<div class="main-sidebar-header">
		<div class="header-logo">
			<h3 class="desktop-logo"><span class="text-primary">Oto</span><span class="text-warning">Solve</span></h3>
			<h3 class="toggle-logo"><span class="text-primary">O</span><span class="text-warning">S</span></h3>
			<h3 class="desktop-dark"><span class="text-primary">Oto</span><span class="text-warning">Solve</span></h3>
			<h3 class="toggle-dark"><span class="text-primary">O</span><span class="text-warning">S</span></h3>
			<h3 class="desktop-white"><span class="text-primary">Oto</span><span class="text-danger">Solve</span></h3>
			<h3 class="toggle-white"><span class="text-primary">Oto</span><span class="text-warning">Solve</span></h3>
		</div>
	</div>
	<!-- End::main-sidebar-header -->
	<!-- Start::main-sidebar -->
	<div class="main-sidebar" id="sidebar-scroll">
		<BlazorOverlayScrollbars @ref="scrollbarsRef" Configurations="configurations">
			<BlazorOverlayScrollbarsContent>
				<!-- Start::nav -->
				<nav class="main-menu-container nav nav-pills flex-column sub-open">
					<div class="slide-left" id="slide-left" @onclick="leftArrowFn">
						<svg xmlns="http://www.w3.org/2000/svg" fill="#7b8191" width="24" height="24"
							 viewBox="0 0 24 24">
							<path d="M13.293 6.293 7.586 12l5.707 5.707 1.414-1.414L10.414 12l4.293-4.293z"></path>
						</svg>
					</div>
					<ul class="main-menu">
						@foreach (var menuItem in MenuDataService.GetMenuData())
						{
							<!-- Start::slide__category -->
							<li class="@GetMenuItemClasses(menuItem)">
								@if (!string.IsNullOrEmpty(menuItem.MenuTitle))
								{
									<span class="category-name">@menuItem.MenuTitle</span>
								}
								@if (menuItem.Type == "link")
								{
									<a href="@menuItem.Path" @onclick="async () => {
                                        await SetSubmenu((menuItem, null));
                                        Navigation.NavigateTo(menuItem.Path);
                                    }" @onclick:preventDefault class="side-menu__item @(menuItem.Selected ? "active" : "")">
										<i class="@(menuItem.Icon) side-menu__icon"></i>
										<span class="side-menu__label">
											@menuItem.Title
											@if (!string.IsNullOrEmpty(menuItem.BadgeValue))
											{
												<span class="badge @(menuItem.BadgeClass) ms-1">@menuItem.BadgeValue</span>
											}
										</span>
									</a>
								}
								@if (menuItem.Type == "external")
								{
									<a href="@menuItem.Path" target="_blank" class="side-menu__item" rel="noopener noreferrer">
										<i class="@(menuItem.Icon) side-menu__icon"></i>
										<span class="side-menu__label">
											@menuItem.Title
											@if (!string.IsNullOrEmpty(menuItem.BadgeValue))
											{
												<span class="badge @(menuItem.BadgeClass) ms-1">@menuItem.BadgeValue</span>
											}
										</span>
									</a>
								}
								@if (menuItem.Type == "empty")
								{
									<a href="javascript:void(0)" class="side-menu__item">
										<i class="@(menuItem.Icon) side-menu__icon"></i>
										<span class="side-menu__label">
											@menuItem.Title
											@if (!string.IsNullOrEmpty(menuItem.BadgeValue))
											{
												<span class="badge @(menuItem.BadgeClass) ms-1">@menuItem.BadgeValue</span>
											}
										</span>
									</a>
								}
								@if (menuItem.Type == "sub")
								{
									<a href="javascript:void(0);" class="side-menu__item" @onclick="() => ToggleSubMenu((menuItem, null))">
										<i class="@(menuItem.Icon) side-menu__icon"></i>
										<span class="side-menu__label">
											@menuItem.Title
											@if (!string.IsNullOrEmpty(menuItem.BadgeValue))
											{
												<span class="badge @(menuItem.BadgeClass) ms-1">@menuItem.BadgeValue</span>
											}
										</span>
										<i class="ft ft-chevron-right side-menu__angle"></i>
									</a>
									@if (menuItem.Children != null && menuItem.Children.Any())
									{
										<ul class="slide-menu @(($"child{level}")) @(menuItem.Active ? "double-menu-active" : "") @(menuItem.DirChange ? "force-left" : "")" style="@(menuItem.Active ? "display : block" : "")">
											@if (level <= 1)
											{
												<li class="slide side-menu__label1">
													<a href="javascript:void(0)">@menuItem.Title</a>
												</li>
											}
											@foreach (var childItem in menuItem.Children)
											{
												<li class="@GetMenuItemClasses(childItem) @(childItem.Type == "sub" ? "has-sub" : "")">
													@if (childItem.Type == "link")
													{
														<a href="@childItem.Path" class="side-menu__item @(childItem.Selected ? "active" : "")"
														   @onclick="async () => {
                                                            await SetSubmenu((childItem, null));
                                                            Navigation.NavigateTo(childItem.Path);
                                                        }" @onclick:preventDefault>
															@childItem.Title
															@if (!string.IsNullOrEmpty(childItem.BadgeValue))
															{
																<span class="badge @(childItem.BadgeClass) ms-1">@childItem.BadgeValue</span>
															}
														</a>
													}
													@if (childItem.Type == "external")
													{
														<a href="@childItem.Path" target="_blank" class="side-menu__item" rel="noopener noreferrer">
															@childItem.Title
															@if (!string.IsNullOrEmpty(childItem.BadgeValue))
															{
																<span class="badge @(childItem.BadgeClass) ms-1">@childItem.BadgeValue</span>
															}
														</a>
													}
													@if (childItem.Type == "empty")
													{
														<a href="javascript:;" class="side-menu__item">
															@childItem.Title
															@if (!string.IsNullOrEmpty(childItem.BadgeValue))
															{
																<span class="badge @(childItem.BadgeClass) ms-1">@childItem.BadgeValue</span>
															}
														</a>
													}
													@if (childItem.Type == "sub")
													{
														<a href="javascript:void(0);" class="side-menu__item" @onclick="() => ToggleSubMenu((childItem, null))">
															@childItem.Title
															@if (!string.IsNullOrEmpty(childItem.BadgeValue))
															{
																<span class="badge @(childItem.BadgeClass) ms-1">@childItem.BadgeValue</span>
															}
															<i class="ft ft-chevron-right side-menu__angle"></i>
														</a>
														@if (childItem.Children != null && childItem.Children.Any())
														{
															<ul class="slide-menu @(($"child{level+1}")) @(childItem.Active ? "double-menu-active" : "") @(childItem.DirChange ? "force-left" : "")" style="@(childItem.Active ? "display : block" : "")">
																@foreach (var grandchildItem in childItem.Children)
																{
																	<li class="@GetMenuItemClasses(grandchildItem)">
																		@if (grandchildItem.Type == "link")
																		{
																			<a href="@grandchildItem.Path" class="side-menu__item @(grandchildItem.Selected ? "active" : "")"
																			   @onclick="async () => {
                                                                                await SetSubmenu((grandchildItem, null));
                                                                                Navigation.NavigateTo(grandchildItem.Path);
                                                                            }" @onclick:preventDefault>
																				@grandchildItem.Title
																				@if (!string.IsNullOrEmpty(grandchildItem.BadgeValue))
																				{
																					<span class="badge @(grandchildItem.BadgeClass) ms-1">@grandchildItem.BadgeValue</span>
																				}
																			</a>
																		}
																	</li>
																}
															</ul>
														}
													}
												</li>
											}
										</ul>
									}
								}
							</li>
							<!-- End::slide__category -->
						}
					</ul>
					<div class="slide-right" id="slide-right" @onclick="rightArrowFn">
						<i class="ft ft-chevron-right side-menu__angle"></i>
					</div>
				</nav>
				<!-- End::nav -->
			</BlazorOverlayScrollbarsContent>
		</BlazorOverlayScrollbars>
	</div>
	<!-- End::main-sidebar -->

</aside>

@code {
	DotNetObjectReference<NavMenu>? dotNetObjectReference;
	private AppState currentState => stateService.GetAppState();
	private string sidebarClass = "";
	private MainMenuItems? topParent;
	private MainMenuItems? currentItem;
	public WMBOSConfigurations? configurations;
	private int screenSize = 1268;
	private List<int> WindowPreSize = new List<int>();
	private BlazorOverlayScrollbars? scrollbarsRef;
	private string? isMenuType = "";
	private List<MainMenuItems>? menuVal;
	private int level = 0;

	// Cache for JS interop results to reduce redundant calls
	private Dictionary<string, object> jsCache = new Dictionary<string, object>();

	[Inject] private NavScrollService? scrollService { get; set; }

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			// Subscribe to all events
			SubscribeToEvents();

			await CheckLayout();

			var currentPath = new Uri(Navigation.Uri).AbsolutePath;
			currentItem = FindMenuItemByPath(menuVal, currentPath != "/" ? currentPath : "/home");

			if (currentItem != null)
			{
				// To Activate on initial load
				await stateService.setCurrentItem(currentItem);
				await SetSubmenu((currentItem, null));
			}

			screenSize = await JSRuntime.InvokeAsync<int>("interop.inner", "innerWidth");
			WindowPreSize.Add(screenSize);

			dotNetObjectReference = DotNetObjectReference.Create(this);
			await JSRuntime.InvokeVoidAsync("resizeFunctions.addresizeListener", dotNetObjectReference);

			if (screenSize < 992)
			{
				await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-toggled", "close");
			}

			// Attach scroll event listener
			await AttachScrollListener();
		}
	}

	private void SubscribeToEvents()
	{
		ActionService.OnActionTriggered += HandleActionTriggered;

		if (scrollService != null)
		{
			scrollService.ScrollModeChanged += HandleScrollModeChanged;
			scrollService.VerticalModeChanged += HandleVerticalModeChanged;
		}

		Navigation.LocationChanged += HandleLocationChanged;
	}

	private async void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
	{
		var currentPath = new Uri(Navigation.Uri).AbsolutePath;
		currentItem = FindMenuItemByPath(menuVal, currentPath != "/" ? currentPath : "/home");

		if (currentItem != null)
		{
			// To Activate on initial load
			await stateService.setCurrentItem(currentItem);
			await SetSubmenu((currentItem, null));
		}
	}

	async void HandleActionTriggered(string actionValue)
	{
		int innerWidth = await JSRuntime.InvokeAsync<int>("interop.inner", "innerWidth");

		if (actionValue == "vertical" && currentItem != null)
		{
			await SetSubmenu((currentItem, null));
		}
		else if (actionValue == "horizontal" && innerWidth > 992)
		{
			closeMenuFn();
		}

		StateHasChanged();
	}

	[JSInvokable]
	public async Task OnWindowResize(int position)
	{
		try
		{
			var layout = await JSRuntime.InvokeAsync<string>("interop.getAttributeToHtml", "data-nav-layout");
			screenSize = position;
			WindowPreSize.Add(position);

			if (WindowPreSize.Count > 2)
			{
				WindowPreSize.RemoveAt(0);
			}

			if (WindowPreSize.Count > 1)
			{
				int recentSize = WindowPreSize[^1];
				int prevSize = WindowPreSize[^2];

				if (recentSize < 992 && prevSize >= 992)
				{
					if (currentItem != null)
					{
						await SetSubmenu((currentItem, null));
					}

					await CheckLayout();
					await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-toggled", "close");
				}
				else if (recentSize >= 992 && prevSize < 992)
				{
					await stateService.navigationStylesFn(currentState.NavigationStyles, false);
					string ynexmenuStyles = currentState.MenuStyles;
					string ynexverticalstyles = currentState.LayoutStyles;

					if (string.IsNullOrEmpty(ynexverticalstyles))
					{
						await stateService.menuStylesFn(ynexmenuStyles);
					}
					else
					{
						await stateService.layoutStylesFn(ynexverticalstyles);
					}

					if (layout == "horizontal")
					{
						closeMenuFn();
					}
					else if (currentItem != null)
					{
						await SetSubmenu((currentItem, null));
					}

					await CheckLayout();
				}
			}

			await checkHoriMenuAsync();
			StateHasChanged();
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error in OnWindowResize: {ex.Message}");
		}
	}

	private void HandleScrollModeChanged(string isMenuType)
	{
		this.isMenuType = isMenuType;
		CheckLayout();
	}

	private void HandleVerticalModeChanged(bool isVertical)
	{
		checkHoriMenuAsync();
		StateHasChanged();
	}

	public async Task CheckLayout()
	{
		var layout = currentState?.NavigationStyles;

		if (this.isMenuType != "")
		{
			await checkHoriMenuAsync();
			StateHasChanged();
		}
	}

	private async Task AttachScrollListener()
	{
		await JSRuntime.InvokeVoidAsync("interop.registerScrollListener", DotNetObjectReference.Create(this));
	}

	[JSInvokable]
	public void SetStickyClass(int scrollY)
	{
		sidebarClass = scrollY >= 75 ? "sticky-pin" : "";
		StateHasChanged();
	}

	public class MenuNavElement
	{
		public int scrollWidth { get; set; }
		public int marginInlineStart { get; set; }
	}

	private async Task MoveMenuAsync(string direction)
	{
		try
		{
			var menuNav = await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavElement", ".main-menu");
			var mainContainer1 = await JSRuntime.InvokeAsync<int>("interop.mainSidebarOffset", ".main-sidebar");
			var marginRightValue = menuNav.marginInlineStart;
			var check = menuNav.scrollWidth - mainContainer1;
			var mainContainer1Width = mainContainer1;

			if (menuNav.scrollWidth > mainContainer1)
			{
				var offset = direction == "right"
					? -Math.Abs(mainContainer1Width)
					: Math.Abs(mainContainer1Width);

				if (direction == "right")
				{
					if (Math.Abs(check) > Math.Abs(marginRightValue))
					{
						mainContainer1Width = Math.Abs(check) - Math.Abs(marginRightValue);
						await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-right", "d-none");
					}
				}
				else
				{
					if (marginRightValue < 0 && !(Math.Abs(marginRightValue) < mainContainer1Width))
					{
						await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavmarginInlineStart", ".main-menu", $"{menuNav.marginInlineStart + Math.Abs(mainContainer1Width)}px");
						await JSRuntime.InvokeAsync<string>("interop.removeClass", ".slide-right", "d-none");
					}
					else
					{
						await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavmarginInlineStart", ".main-menu", "0px");
						await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-left", "d-none");
					}
				}

				await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavmarginInlineStart", ".main-menu", $"{menuNav.marginInlineStart + offset}px");
				await JSRuntime.InvokeAsync<string>("interop.removeClass", $".slide-{direction}", "d-none");
			}
			else
			{
				await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavmarginInlineStart", ".main-menu", "0px");
				await JSRuntime.InvokeAsync<string>("interop.addClass", $".slide-{direction}", "d-none");
			}
			closeMenuFn();
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error in MoveMenuAsync: {ex.Message}");
		}
	}

	private Task rightArrowFn() => MoveMenuAsync("right");
	private Task leftArrowFn() => MoveMenuAsync("left");

	private async Task checkHoriMenuAsync()
	{
		try
		{
			await Task.Delay(500);
			var menuNav = await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavElement", ".main-menu");
			var mainContainer1 = await JSRuntime.InvokeAsync<int>("interop.mainSidebarOffset", ".main-sidebar");
			var marginRightValue = menuNav.marginInlineStart;
			var check = menuNav.scrollWidth - mainContainer1;

			if (menuNav.scrollWidth > mainContainer1)
			{
				await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-left", "d-none");
				await JSRuntime.InvokeAsync<string>("interop.removeClass", ".slide-right", "d-none");
			}
			else
			{
				await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-left", "d-none");
				await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-right", "d-none");
				await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavmarginInlineStart", ".main-menu", "0px");
			}

			if (menuNav.scrollWidth > mainContainer1 && Math.Abs(check) < Math.Abs(marginRightValue))
			{
				await JSRuntime.InvokeAsync<MenuNavElement>("interop.MenuNavmarginInlineStart", ".main-menu", $"{-check}px");
				await JSRuntime.InvokeAsync<string>("interop.removeClass", ".slide-left", "d-none");
				await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-right", "d-none");
			}

			if (marginRightValue == 0)
			{
				await JSRuntime.InvokeAsync<string>("interop.addClass", ".slide-left", "d-none");
			}
			else
			{
				await JSRuntime.InvokeAsync<string>("interop.removeClass", ".slide-right", "d-none");
			}

			if (marginRightValue != 0)
			{
				await JSRuntime.InvokeAsync<string>("interop.removeClass", ".slide-left", "d-none");
			}

			if (menuVal != null)
			{
				foreach (var item in menuVal.ToArray())
				{
					if (item.Children != null)
					{
						await ProcessMenuChildrenDirectionChange(item.Children);
					}
				}
			}
		}
		catch (JSDisconnectedException)
		{
			// Optionally, add logging for JS disconnection
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error in checkHoriMenuAsync: {ex.Message}");
		}
	}

	// Process menu children direction changes
	private async Task ProcessMenuChildrenDirectionChange(IEnumerable<MainMenuItems> children)
	{
		foreach (var item in children)
		{
			if (item.RandomNumber > 0)
			{
				item.DirChange = await JSRuntime.InvokeAsync<bool>("interop.directionChange", item.RandomNumber);
				if (item.Children != null)
				{
					await ProcessMenuChildrenDirectionChange(item.Children);
				}
			}
		}
	}

	protected override async Task OnInitializedAsync()
	{
		menuVal = MenuDataService.GetMenuData();
		await Random(menuVal);
		configurations = new WMBOSConfigurations
			{
				overflowBehavior = { x = "scroll" },
				scrollbars = { dragScrolling = false }
			};
	}

	private MainMenuItems? FindMenuItemByPath(IEnumerable<MainMenuItems>? items, string path)
	{
		if (items == null || string.IsNullOrEmpty(path))
		{
			return null;
		}
		foreach (var item in items)
		{
			if (item.Path == path)
			{
				return item;
			}
			if (item.Children != null)
			{
				var nestedItem = FindMenuItemByPath(item.Children, path);
				if (nestedItem != null)
				{
					return nestedItem;
				}
			}
		}
		return null;
	}

	private async Task Random(List<MainMenuItems>? menuData)
	{
		if (menuData == null)
			return;

		Random rand = new Random();
		foreach (var item in menuData)
		{
			item.RandomNumber = rand.Next(1000); // Assign random number for direction change detection
			if (item.Children != null)
			{
				await Random(item.Children.ToList());
			}
		}
	}

	private async Task ToggleSubMenu((MainMenuItems targetObject, MainMenuItems[]? menuData) data)
	{
		try
		{
			MainMenuItems targetObject = data.targetObject;
			MainMenuItems[]? menuData = data.menuData;

			// If menu data is empty, use the full menu
			if ((menuData == null || menuData.Length == 0) && menuVal != null)
			{
				menuData = menuVal.ToArray();
			}

			Console.WriteLine($"Toggling submenu for: {targetObject.Title}, Current Active: {targetObject.Active}");

			// Toggle the target menu item's active state
			targetObject.Active = !targetObject.Active;
			Console.WriteLine($"New Active state: {targetObject.Active}");

			if (targetObject.Active)
			{
				// Close other menus at the same level
				CloseOtherMenus(menuData, targetObject);
			}

			// Get vertical style
			var verticalStyle = await JSRuntime.InvokeAsync<string>("interop.getAttributeToHtml", "data-vertical-style");

			// Handle special case for doublemenu
			if (targetObject.Children != null && targetObject.Active && verticalStyle == "doublemenu")
			{
				await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-toggled", "double-menu-open");
			}

			// Update UI
			StateHasChanged();
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error in ToggleSubMenu: {ex.Message}");
		}
	}

	private async Task SetAncestorsActive(IEnumerable<MainMenuItems> items, MainMenuItems targetObject, string? verticalStyle = null)
	{
		if (verticalStyle == null)
		{
			verticalStyle = await JSRuntime.InvokeAsync<string>("interop.getAttributeToHtml", "data-vertical-style");
		}

		var parent = FindParent(items, targetObject);
		if (parent != null)
		{
			parent.Active = true;
			await SetAncestorsActive(items, parent, verticalStyle);
		}
	}

	private void CloseOtherMenus(IEnumerable<MainMenuItems> menuData, MainMenuItems targetObject)
	{
		foreach (var item in menuData)
		{
			if (item != targetObject)
			{
				item.Active = false;
				if (item.Children != null && item.Children.Any())
				{
					CloseOtherMenus(item.Children, targetObject);
				}
			}
		}
	}

	private MainMenuItems? FindParent(IEnumerable<MainMenuItems> items, MainMenuItems targetObject)
	{
		foreach (var item in items)
		{
			if (item.Children != null && item.Children.Contains(targetObject))
			{
				return item;
			}
			if (item.Children != null && item.Children.Any())
			{
				var parent = FindParent(item.Children, targetObject);
				if (parent != null)
				{
					return parent;
				}
			}
		}
		return null;
	}

	private async Task SetSubmenu((MainMenuItems targetObject, MainMenuItems[]? menuData) data)
	{
		try
		{
			var innerLevel = false;
			var (targetObject, menuData) = data;

			if ((menuData == null || menuData.Length == 0) && menuVal != null)
			{
				menuData = menuVal.ToArray();
			}
			else
			{
				innerLevel = true;
			}

			foreach (var item in menuData!)
			{
				try
				{
					if (item == targetObject)
					{
						if (item.Type == "link" && !innerLevel)
						{
							try
							{
								await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-toggled", "double-menu-close");
							}
							catch (Exception jsEx)
							{
								Console.WriteLine($"JS Interop error when adding attribute: {jsEx.Message}");
							}
						}

						try
						{
							var inner = await JSRuntime.InvokeAsync<int>("interop.inner", "innerWidth");
							if (currentState?.NavigationStyles != "horizontal" || inner < 992)
							{
								item.Active = true;
							}
						}
						catch (Exception jsWidthEx)
						{
							Console.WriteLine($"JS Interop error when getting inner width: {jsWidthEx.Message}");
							// Fallback behavior if we can't get the inner width
							if (currentState?.NavigationStyles != "horizontal")
							{
								item.Active = true;
							}
						}

						item.Selected = true;
						SetMenuAncestorsActive(item);
					}
					else if (!item.Active && !item.Selected)
					{
						item.Active = false;
						item.Selected = false;
					}

					if (item.Children != null && item.Children.Any())
					{
						await SetSubmenu((targetObject, item.Children.ToArray()));
					}
				}
				catch (Exception itemEx)
				{
					Console.WriteLine($"Error processing menu item: {itemEx.Message}");
				}
			}

			StateHasChanged();
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error in SetSubmenu: {ex.Message}");
		}
	}

	private async void SetMenuAncestorsActive(MainMenuItems targetObject)
	{
		var parent = GetParentObject(menuVal, targetObject);
		if (parent != null)
		{
			var inner = await JSRuntime.InvokeAsync<int>("interop.inner", "innerWidth");
			var navLayout = currentState?.NavigationStyles;

			if (parent?.Children != null && topParent != null && targetObject != null)
			{
				foreach (var item in parent.Children)
				{
					if (item != topParent && item != targetObject)
					{
						RemoveActiveOtherMenus(item, targetObject);
					}
				}
			}

			if (navLayout != "horizontal" || inner < 992)
			{
				parent.Active = true;
			}
			parent.Selected = true;

			topParent = parent;
			if (parent != null)
			{
				SetMenuAncestorsActive(parent);
			}
		}
		else
		{
			if (targetObject?.Title != topParent?.Title)
			{
				topParent = null;
			}
			else if (targetObject?.Type == "link")
			{
				topParent = null;
			}

			var dummyMenuItems = menuVal?.Where(item => item != topParent).ToList();
			if (dummyMenuItems != null)
			{
				foreach (var item in dummyMenuItems)
				{
					RemoveActiveOtherMenus(item, targetObject);
				}
			}
		}
		StateHasChanged();
	}

	private MainMenuItems? GetParentObject(IEnumerable<MainMenuItems>? items, MainMenuItems childObject)
	{
		if (items == null || childObject == null) return null;
		foreach (var item in items)
		{
			if (item.Children != null && item.Children.Contains(childObject))
			{
				return item;
			}

			var parent = GetParentObject(item.Children, childObject);
			if (parent != null)
			{
				return parent;
			}
		}
		return null;
	}

	private void RemoveActiveOtherMenus(MainMenuItems item, MainMenuItems targetObject)
	{
		if (item != null)
		{
			if (item.Title != targetObject.Title)
			{
				item.Active = false;
				item.Selected = false;
			}
			if (item.Children != null && item.Children.Any())
			{
				foreach (var child in item.Children)
				{
					child.Active = false;
					child.Selected = false;
					RemoveActiveOtherMenus(child, targetObject);
				}
			}
		}
	}

	private string GetMenuItemClasses(MainMenuItems menuItem)
	{
		var classes = new List<string>();
		if (!string.IsNullOrEmpty(menuItem.MenuTitle))
		{
			classes.Add("slide__category");
		}
		if (menuItem.Type == "empty" || menuItem.Type == "link" || menuItem.Type == "external" || menuItem.Type == "sub")
		{
			classes.Add("slide");
		}
		if (menuItem.Active)
		{
			classes.Add("open");
		}
		if (menuItem.Selected)
		{
			classes.Add("active");
		}
		return string.Join(" ", classes);
	}

	public void closeMenuFn()
	{
		void closeMenuRecursively(IEnumerable<MainMenuItems>? items)
		{
			if (items == null) return;
			foreach (var item in items)
			{
				item.Active = false;
				closeMenuRecursively(item.Children);
			}
		}
		closeMenuRecursively(menuVal);
		StateHasChanged();
	}

	private async Task HoverToggleInnerMenuFn(bool isMouseOver)
	{
		var dataToggled = await JSRuntime.InvokeAsync<string>("interop.getAttributeToHtml", "data-toggled");
		if (dataToggled == "icon-overlay-close" || dataToggled == "detached-close")
		{
			if (isMouseOver)
			{
				await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-icon-overlay", "open");
			}
			else
			{
				await JSRuntime.InvokeAsync<string>("interop.removeAttributeFromHtml", "data-icon-overlay");
			}
		}
	}

	private async Task icontextOpenFn()
	{
		var dataToggled = await JSRuntime.InvokeAsync<string>("interop.getAttributeToHtml", "data-toggled");
		if (dataToggled == "icon-text-close")
		{
			await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-icon-text", "open");
		}
	}

	private async Task responsivecloseFn()
	{
		try
		{
			var toggled = await JSRuntime.InvokeAsync<string>("interop.getAttributeToHtml", "data-toggled");

			if (toggled == "open")
			{
				await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-toggled", "close");
			}
			else
			{
				await JSRuntime.InvokeAsync<string>("interop.addAttributeToHtml", "data-toggled", "open");
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error in responsivecloseFn: {ex.Message}");
		}
	}

	public void Dispose()
	{
		// Unsubscribe from all events to prevent memory leaks
		if (dotNetObjectReference != null)
		{
			try
			{
				JSRuntime.InvokeVoidAsync("resizeFunctions.detachScrollListener");
				dotNetObjectReference.Dispose();
			}
			catch
			{
				// Swallow exceptions during disposal
			}
		}

		ActionService.OnActionTriggered -= HandleActionTriggered;
		Navigation.LocationChanged -= HandleLocationChanged;

		if (scrollService != null)
		{
			scrollService.ScrollModeChanged -= HandleScrollModeChanged;
			scrollService.VerticalModeChanged -= HandleVerticalModeChanged;
		}
	}
}